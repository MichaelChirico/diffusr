---
title: "The diffusr tutorial"
author: "Simon Dirmeier"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{The diffusr tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Introduction

`diffusr` implements algorithms for network diffusion such as *Markov random walks with restarts* and *weighted neighbor classification*. Network diffusion has been studied extensively in bioinformatics, e.g. in the field of cancer gene prioritization. Network diffusion algorithms generally spread information in the form of node weights along the edges of a graph to other nodes. These weights can for example be interpreted as temperature, an initial amount of water, the activation of neurons in the brain, or the location of a random surfer in the internet. The information (node weights) is iteratively propagated to other nodes until a equilibrium state or stop criterion occurs.

## Tutorial

First load the package:

```{r}
library(diffusr)
```

### Markov random walks

A *Markov random walk with restarts* calculates the stationary distribution:
\begin{equation}
\mathbf{p}_{t+1} = (1 - r) \mathbf{W}  \mathbf{p}_t + r \mathbf{p}_0,
\end{equation}
where $r \in \{0,1 \}$ is a *restart probability* of the Markov chain, $\mathbf{W}$ is a column-normalized stochastic matrix (we do the normalization for you) an $\mathbf{p}_0$ is the starting distribution of the Markov chain. We calculate the iterative updates, it is also possible to do the math using the nullspace of the matrix (comes later).

If you want to use Markov random walks just try something like this:

```{r}
  # count of nodes
  n <- 5
  # starting distribution (has to sum to one)
  p0    <- rmultinom(1, 1, prob=rep(.2, n))
  # adjacency matrix (either normalized or not)
  graph <- matrix(abs(rnorm(n*n)), n, n)
  # computation of stationary distribution
  pt    <- random.walk(p0, graph)
```
 
The stationary distribution should have changed quite a bit from the starting distribution:

```{r}
  print(t(p0))
  print(t(pt))
```

### Nearest neighbor search

*Nearest neighbor search* is straight-forward. We just traverse through the graph and take all the neighbors of a node until a certain depths in the graph is reached:

```{r}
  # count of nodes
  n <- 10
  # indexes(integer) of nodes for which neighbors should be searched 
  node.idxs <- c(1L, 5L)
  # the adjaceny matrix (does not need to be symmetric)
  graph <- rbind(cbind(0, diag(n-1)), 0)
  # compte the neighbors until depth 3
  neighs <- neighbors(node.idxs, graph, 3)
```

Let's see what we got:

```{r}
  print(neighs)
```


That's all so far.
